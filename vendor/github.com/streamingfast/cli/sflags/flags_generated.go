// Code generated by generate_flags, DO NOT EDIT!
package sflags

import (
	"errors"
	"fmt"
	"net"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"github.com/streamingfast/cli"
)

var ErrViperTypeNotSupported = errors.New("viper type not supported")

type ErrFlagNotExist struct {
	Name string
}

func (e *ErrFlagNotExist) Error() string {
	return fmt.Sprintf("flag %q does not exist", e.Name)
}


// MustGetBoolSliceProvided is exactly like [MustGetBoolSlice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetBoolSliceProvided(cmd *cobra.Command, name string) ([]bool, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "BoolSlice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetBoolSlice(name)
	cli.NoError(err, `Read flag %q via "GetBoolSlice" failed`, name)

	return out, flag.Changed
}

// MustGetBoolSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetBoolSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetBoolSlice(cmd *cobra.Command, name string) []bool {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "BoolSlice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetBoolSlice(name)
	cli.NoError(err, `Read flag %q via "GetBoolSlice" failed`, name)

	return out
}

// GetBoolSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetBoolSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetBoolSlice(cmd *cobra.Command, name string) (out []bool, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "BoolSlice" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetBoolSlice(name)
}

// MustGetUint8Provided is exactly like [MustGetUint8] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetUint8Provided(cmd *cobra.Command, name string) (uint8, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return uint8(viper.GetUint16(reboundKey)), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetUint8(name)
	cli.NoError(err, `Read flag %q via "GetUint8" failed`, name)

	return out, flag.Changed
}

// MustGetUint8 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint16]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint8(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetUint8(cmd *cobra.Command, name string) uint8 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return uint8(viper.GetUint16(reboundKey))
	}

	out, err := cmd.Flags().GetUint8(name)
	cli.NoError(err, `Read flag %q via "GetUint8" failed`, name)

	return out
}

// GetUint8 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint16]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint8(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetUint8(cmd *cobra.Command, name string) (out uint8, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return uint8(viper.GetUint16(reboundKey)), nil
	}

	return cmd.Flags().GetUint8(name)
}

// MustGetStringSliceProvided is exactly like [MustGetStringSlice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetStringSliceProvided(cmd *cobra.Command, name string) ([]string, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringSlice(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetStringSlice(name)
	cli.NoError(err, `Read flag %q via "GetStringSlice" failed`, name)

	return out, flag.Changed
}

// MustGetStringSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetStringSlice]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetStringSlice(cmd *cobra.Command, name string) []string {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringSlice(reboundKey)
	}

	out, err := cmd.Flags().GetStringSlice(name)
	cli.NoError(err, `Read flag %q via "GetStringSlice" failed`, name)

	return out
}

// GetStringSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetStringSlice]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetStringSlice(cmd *cobra.Command, name string) (out []string, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringSlice(reboundKey), nil
	}

	return cmd.Flags().GetStringSlice(name)
}

// MustGetIPSliceProvided is exactly like [MustGetIPSlice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetIPSliceProvided(cmd *cobra.Command, name string) ([]net.IP, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "IPSlice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetIPSlice(name)
	cli.NoError(err, `Read flag %q via "GetIPSlice" failed`, name)

	return out, flag.Changed
}

// MustGetIPSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIPSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetIPSlice(cmd *cobra.Command, name string) []net.IP {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "IPSlice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetIPSlice(name)
	cli.NoError(err, `Read flag %q via "GetIPSlice" failed`, name)

	return out
}

// GetIPSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIPSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetIPSlice(cmd *cobra.Command, name string) (out []net.IP, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "IPSlice" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetIPSlice(name)
}

// MustGetStringToStringProvided is exactly like [MustGetStringToString] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetStringToStringProvided(cmd *cobra.Command, name string) (map[string]string, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringMapString(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetStringToString(name)
	cli.NoError(err, `Read flag %q via "GetStringToString" failed`, name)

	return out, flag.Changed
}

// MustGetStringToString returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetStringMapString]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringToString(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetStringToString(cmd *cobra.Command, name string) map[string]string {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringMapString(reboundKey)
	}

	out, err := cmd.Flags().GetStringToString(name)
	cli.NoError(err, `Read flag %q via "GetStringToString" failed`, name)

	return out
}

// GetStringToString returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetStringMapString]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringToString(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetStringToString(cmd *cobra.Command, name string) (out map[string]string, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringMapString(reboundKey), nil
	}

	return cmd.Flags().GetStringToString(name)
}

// MustGetFloat64Provided is exactly like [MustGetFloat64] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetFloat64Provided(cmd *cobra.Command, name string) (float64, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetFloat64(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetFloat64(name)
	cli.NoError(err, `Read flag %q via "GetFloat64" failed`, name)

	return out, flag.Changed
}

// MustGetFloat64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetFloat64]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetFloat64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetFloat64(cmd *cobra.Command, name string) float64 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetFloat64(reboundKey)
	}

	out, err := cmd.Flags().GetFloat64(name)
	cli.NoError(err, `Read flag %q via "GetFloat64" failed`, name)

	return out
}

// GetFloat64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetFloat64]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetFloat64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetFloat64(cmd *cobra.Command, name string) (out float64, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetFloat64(reboundKey), nil
	}

	return cmd.Flags().GetFloat64(name)
}

// MustGetUint32Provided is exactly like [MustGetUint32] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetUint32Provided(cmd *cobra.Command, name string) (uint32, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint32(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetUint32(name)
	cli.NoError(err, `Read flag %q via "GetUint32" failed`, name)

	return out, flag.Changed
}

// MustGetUint32 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint32]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint32(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetUint32(cmd *cobra.Command, name string) uint32 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint32(reboundKey)
	}

	out, err := cmd.Flags().GetUint32(name)
	cli.NoError(err, `Read flag %q via "GetUint32" failed`, name)

	return out
}

// GetUint32 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint32]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint32(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetUint32(cmd *cobra.Command, name string) (out uint32, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint32(reboundKey), nil
	}

	return cmd.Flags().GetUint32(name)
}

// MustGetDurationSliceProvided is exactly like [MustGetDurationSlice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetDurationSliceProvided(cmd *cobra.Command, name string) ([]time.Duration, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "DurationSlice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetDurationSlice(name)
	cli.NoError(err, `Read flag %q via "GetDurationSlice" failed`, name)

	return out, flag.Changed
}

// MustGetDurationSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetDurationSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetDurationSlice(cmd *cobra.Command, name string) []time.Duration {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "DurationSlice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetDurationSlice(name)
	cli.NoError(err, `Read flag %q via "GetDurationSlice" failed`, name)

	return out
}

// GetDurationSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetDurationSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetDurationSlice(cmd *cobra.Command, name string) (out []time.Duration, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "DurationSlice" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetDurationSlice(name)
}

// MustGetUint16Provided is exactly like [MustGetUint16] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetUint16Provided(cmd *cobra.Command, name string) (uint16, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint16(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetUint16(name)
	cli.NoError(err, `Read flag %q via "GetUint16" failed`, name)

	return out, flag.Changed
}

// MustGetUint16 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint16]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint16(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetUint16(cmd *cobra.Command, name string) uint16 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint16(reboundKey)
	}

	out, err := cmd.Flags().GetUint16(name)
	cli.NoError(err, `Read flag %q via "GetUint16" failed`, name)

	return out
}

// GetUint16 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint16]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint16(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetUint16(cmd *cobra.Command, name string) (out uint16, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint16(reboundKey), nil
	}

	return cmd.Flags().GetUint16(name)
}

// MustGetFloat32SliceProvided is exactly like [MustGetFloat32Slice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetFloat32SliceProvided(cmd *cobra.Command, name string) ([]float32, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Float32Slice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetFloat32Slice(name)
	cli.NoError(err, `Read flag %q via "GetFloat32Slice" failed`, name)

	return out, flag.Changed
}

// MustGetFloat32Slice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetFloat32Slice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetFloat32Slice(cmd *cobra.Command, name string) []float32 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Float32Slice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetFloat32Slice(name)
	cli.NoError(err, `Read flag %q via "GetFloat32Slice" failed`, name)

	return out
}

// GetFloat32Slice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetFloat32Slice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetFloat32Slice(cmd *cobra.Command, name string) (out []float32, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "Float32Slice" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetFloat32Slice(name)
}

// MustGetDurationProvided is exactly like [MustGetDuration] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetDurationProvided(cmd *cobra.Command, name string) (time.Duration, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetDuration(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetDuration(name)
	cli.NoError(err, `Read flag %q via "GetDuration" failed`, name)

	return out, flag.Changed
}

// MustGetDuration returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetDuration]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetDuration(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetDuration(cmd *cobra.Command, name string) time.Duration {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetDuration(reboundKey)
	}

	out, err := cmd.Flags().GetDuration(name)
	cli.NoError(err, `Read flag %q via "GetDuration" failed`, name)

	return out
}

// GetDuration returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetDuration]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetDuration(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetDuration(cmd *cobra.Command, name string) (out time.Duration, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetDuration(reboundKey), nil
	}

	return cmd.Flags().GetDuration(name)
}

// MustGetInt64Provided is exactly like [MustGetInt64] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetInt64Provided(cmd *cobra.Command, name string) (int64, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt64(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetInt64(name)
	cli.NoError(err, `Read flag %q via "GetInt64" failed`, name)

	return out, flag.Changed
}

// MustGetInt64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt64]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetInt64(cmd *cobra.Command, name string) int64 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt64(reboundKey)
	}

	out, err := cmd.Flags().GetInt64(name)
	cli.NoError(err, `Read flag %q via "GetInt64" failed`, name)

	return out
}

// GetInt64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt64]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetInt64(cmd *cobra.Command, name string) (out int64, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt64(reboundKey), nil
	}

	return cmd.Flags().GetInt64(name)
}

// MustGetUintSliceProvided is exactly like [MustGetUintSlice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetUintSliceProvided(cmd *cobra.Command, name string) ([]uint, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "UintSlice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetUintSlice(name)
	cli.NoError(err, `Read flag %q via "GetUintSlice" failed`, name)

	return out, flag.Changed
}

// MustGetUintSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUintSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetUintSlice(cmd *cobra.Command, name string) []uint {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "UintSlice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetUintSlice(name)
	cli.NoError(err, `Read flag %q via "GetUintSlice" failed`, name)

	return out
}

// GetUintSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUintSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetUintSlice(cmd *cobra.Command, name string) (out []uint, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "UintSlice" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetUintSlice(name)
}

// MustGetBoolProvided is exactly like [MustGetBool] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetBoolProvided(cmd *cobra.Command, name string) (bool, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetBool(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetBool(name)
	cli.NoError(err, `Read flag %q via "GetBool" failed`, name)

	return out, flag.Changed
}

// MustGetBool returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetBool]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetBool(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetBool(cmd *cobra.Command, name string) bool {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetBool(reboundKey)
	}

	out, err := cmd.Flags().GetBool(name)
	cli.NoError(err, `Read flag %q via "GetBool" failed`, name)

	return out
}

// GetBool returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetBool]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetBool(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetBool(cmd *cobra.Command, name string) (out bool, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetBool(reboundKey), nil
	}

	return cmd.Flags().GetBool(name)
}

// MustGetInt32SliceProvided is exactly like [MustGetInt32Slice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetInt32SliceProvided(cmd *cobra.Command, name string) ([]int32, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Int32Slice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetInt32Slice(name)
	cli.NoError(err, `Read flag %q via "GetInt32Slice" failed`, name)

	return out, flag.Changed
}

// MustGetInt32Slice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt32Slice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetInt32Slice(cmd *cobra.Command, name string) []int32 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Int32Slice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetInt32Slice(name)
	cli.NoError(err, `Read flag %q via "GetInt32Slice" failed`, name)

	return out
}

// GetInt32Slice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt32Slice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetInt32Slice(cmd *cobra.Command, name string) (out []int32, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "Int32Slice" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetInt32Slice(name)
}

// MustGetInt32Provided is exactly like [MustGetInt32] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetInt32Provided(cmd *cobra.Command, name string) (int32, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt32(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetInt32(name)
	cli.NoError(err, `Read flag %q via "GetInt32" failed`, name)

	return out, flag.Changed
}

// MustGetInt32 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt32]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt32(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetInt32(cmd *cobra.Command, name string) int32 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt32(reboundKey)
	}

	out, err := cmd.Flags().GetInt32(name)
	cli.NoError(err, `Read flag %q via "GetInt32" failed`, name)

	return out
}

// GetInt32 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt32]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt32(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetInt32(cmd *cobra.Command, name string) (out int32, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt32(reboundKey), nil
	}

	return cmd.Flags().GetInt32(name)
}

// MustGetStringToIntProvided is exactly like [MustGetStringToInt] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetStringToIntProvided(cmd *cobra.Command, name string) (map[string]int, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "StringToInt" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetStringToInt(name)
	cli.NoError(err, `Read flag %q via "GetStringToInt" failed`, name)

	return out, flag.Changed
}

// MustGetStringToInt returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringToInt(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetStringToInt(cmd *cobra.Command, name string) map[string]int {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "StringToInt" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetStringToInt(name)
	cli.NoError(err, `Read flag %q via "GetStringToInt" failed`, name)

	return out
}

// GetStringToInt returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringToInt(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetStringToInt(cmd *cobra.Command, name string) (out map[string]int, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "StringToInt" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetStringToInt(name)
}

// MustGetInt16Provided is exactly like [MustGetInt16] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetInt16Provided(cmd *cobra.Command, name string) (int16, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return int16(viper.GetInt32(reboundKey)), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetInt16(name)
	cli.NoError(err, `Read flag %q via "GetInt16" failed`, name)

	return out, flag.Changed
}

// MustGetInt16 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt32]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt16(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetInt16(cmd *cobra.Command, name string) int16 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return int16(viper.GetInt32(reboundKey))
	}

	out, err := cmd.Flags().GetInt16(name)
	cli.NoError(err, `Read flag %q via "GetInt16" failed`, name)

	return out
}

// GetInt16 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt32]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt16(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetInt16(cmd *cobra.Command, name string) (out int16, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return int16(viper.GetInt32(reboundKey)), nil
	}

	return cmd.Flags().GetInt16(name)
}

// MustGetIPProvided is exactly like [MustGetIP] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetIPProvided(cmd *cobra.Command, name string) (net.IP, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "IP" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetIP(name)
	cli.NoError(err, `Read flag %q via "GetIP" failed`, name)

	return out, flag.Changed
}

// MustGetIP returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIP(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetIP(cmd *cobra.Command, name string) net.IP {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "IP" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetIP(name)
	cli.NoError(err, `Read flag %q via "GetIP" failed`, name)

	return out
}

// GetIP returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIP(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetIP(cmd *cobra.Command, name string) (out net.IP, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "IP" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetIP(name)
}

// MustGetIPNetProvided is exactly like [MustGetIPNet] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetIPNetProvided(cmd *cobra.Command, name string) (net.IPNet, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "IPNet" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetIPNet(name)
	cli.NoError(err, `Read flag %q via "GetIPNet" failed`, name)

	return out, flag.Changed
}

// MustGetIPNet returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIPNet(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetIPNet(cmd *cobra.Command, name string) net.IPNet {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "IPNet" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetIPNet(name)
	cli.NoError(err, `Read flag %q via "GetIPNet" failed`, name)

	return out
}

// GetIPNet returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIPNet(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetIPNet(cmd *cobra.Command, name string) (out net.IPNet, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "IPNet" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetIPNet(name)
}

// MustGetUint64Provided is exactly like [MustGetUint64] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetUint64Provided(cmd *cobra.Command, name string) (uint64, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint64(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetUint64(name)
	cli.NoError(err, `Read flag %q via "GetUint64" failed`, name)

	return out, flag.Changed
}

// MustGetUint64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint64]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetUint64(cmd *cobra.Command, name string) uint64 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint64(reboundKey)
	}

	out, err := cmd.Flags().GetUint64(name)
	cli.NoError(err, `Read flag %q via "GetUint64" failed`, name)

	return out
}

// GetUint64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint64]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetUint64(cmd *cobra.Command, name string) (out uint64, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint64(reboundKey), nil
	}

	return cmd.Flags().GetUint64(name)
}

// MustGetStringToInt64Provided is exactly like [MustGetStringToInt64] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetStringToInt64Provided(cmd *cobra.Command, name string) (map[string]int64, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "StringToInt64" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetStringToInt64(name)
	cli.NoError(err, `Read flag %q via "GetStringToInt64" failed`, name)

	return out, flag.Changed
}

// MustGetStringToInt64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringToInt64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetStringToInt64(cmd *cobra.Command, name string) map[string]int64 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "StringToInt64" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetStringToInt64(name)
	cli.NoError(err, `Read flag %q via "GetStringToInt64" failed`, name)

	return out
}

// GetStringToInt64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringToInt64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetStringToInt64(cmd *cobra.Command, name string) (out map[string]int64, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "StringToInt64" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetStringToInt64(name)
}

// MustGetFloat32Provided is exactly like [MustGetFloat32] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetFloat32Provided(cmd *cobra.Command, name string) (float32, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return float32(viper.GetFloat64(reboundKey)), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetFloat32(name)
	cli.NoError(err, `Read flag %q via "GetFloat32" failed`, name)

	return out, flag.Changed
}

// MustGetFloat32 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetFloat64]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetFloat32(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetFloat32(cmd *cobra.Command, name string) float32 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return float32(viper.GetFloat64(reboundKey))
	}

	out, err := cmd.Flags().GetFloat32(name)
	cli.NoError(err, `Read flag %q via "GetFloat32" failed`, name)

	return out
}

// GetFloat32 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetFloat64]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetFloat32(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetFloat32(cmd *cobra.Command, name string) (out float32, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return float32(viper.GetFloat64(reboundKey)), nil
	}

	return cmd.Flags().GetFloat32(name)
}

// MustGetIPv4MaskProvided is exactly like [MustGetIPv4Mask] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetIPv4MaskProvided(cmd *cobra.Command, name string) (net.IPMask, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "IPv4Mask" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetIPv4Mask(name)
	cli.NoError(err, `Read flag %q via "GetIPv4Mask" failed`, name)

	return out, flag.Changed
}

// MustGetIPv4Mask returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIPv4Mask(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetIPv4Mask(cmd *cobra.Command, name string) net.IPMask {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "IPv4Mask" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetIPv4Mask(name)
	cli.NoError(err, `Read flag %q via "GetIPv4Mask" failed`, name)

	return out
}

// GetIPv4Mask returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIPv4Mask(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetIPv4Mask(cmd *cobra.Command, name string) (out net.IPMask, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "IPv4Mask" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetIPv4Mask(name)
}

// MustGetCountProvided is exactly like [MustGetCount] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetCountProvided(cmd *cobra.Command, name string) (int, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Count" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetCount(name)
	cli.NoError(err, `Read flag %q via "GetCount" failed`, name)

	return out, flag.Changed
}

// MustGetCount returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetCount(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetCount(cmd *cobra.Command, name string) int {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Count" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetCount(name)
	cli.NoError(err, `Read flag %q via "GetCount" failed`, name)

	return out
}

// GetCount returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetCount(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetCount(cmd *cobra.Command, name string) (out int, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "Count" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetCount(name)
}

// MustGetIntProvided is exactly like [MustGetInt] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetIntProvided(cmd *cobra.Command, name string) (int, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetInt(name)
	cli.NoError(err, `Read flag %q via "GetInt" failed`, name)

	return out, flag.Changed
}

// MustGetInt returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetInt(cmd *cobra.Command, name string) int {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt(reboundKey)
	}

	out, err := cmd.Flags().GetInt(name)
	cli.NoError(err, `Read flag %q via "GetInt" failed`, name)

	return out
}

// GetInt returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetInt(cmd *cobra.Command, name string) (out int, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetInt(reboundKey), nil
	}

	return cmd.Flags().GetInt(name)
}

// MustGetUintProvided is exactly like [MustGetUint] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetUintProvided(cmd *cobra.Command, name string) (uint, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetUint(name)
	cli.NoError(err, `Read flag %q via "GetUint" failed`, name)

	return out, flag.Changed
}

// MustGetUint returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetUint(cmd *cobra.Command, name string) uint {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint(reboundKey)
	}

	out, err := cmd.Flags().GetUint(name)
	cli.NoError(err, `Read flag %q via "GetUint" failed`, name)

	return out
}

// GetUint returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetUint]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetUint(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetUint(cmd *cobra.Command, name string) (out uint, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetUint(reboundKey), nil
	}

	return cmd.Flags().GetUint(name)
}

// MustGetFloat64SliceProvided is exactly like [MustGetFloat64Slice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetFloat64SliceProvided(cmd *cobra.Command, name string) ([]float64, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Float64Slice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetFloat64Slice(name)
	cli.NoError(err, `Read flag %q via "GetFloat64Slice" failed`, name)

	return out, flag.Changed
}

// MustGetFloat64Slice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetFloat64Slice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetFloat64Slice(cmd *cobra.Command, name string) []float64 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Float64Slice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetFloat64Slice(name)
	cli.NoError(err, `Read flag %q via "GetFloat64Slice" failed`, name)

	return out
}

// GetFloat64Slice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetFloat64Slice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetFloat64Slice(cmd *cobra.Command, name string) (out []float64, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "Float64Slice" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetFloat64Slice(name)
}

// MustGetInt8Provided is exactly like [MustGetInt8] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetInt8Provided(cmd *cobra.Command, name string) (int8, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return int8(viper.GetInt32(reboundKey)), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetInt8(name)
	cli.NoError(err, `Read flag %q via "GetInt8" failed`, name)

	return out, flag.Changed
}

// MustGetInt8 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt32]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt8(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetInt8(cmd *cobra.Command, name string) int8 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return int8(viper.GetInt32(reboundKey))
	}

	out, err := cmd.Flags().GetInt8(name)
	cli.NoError(err, `Read flag %q via "GetInt8" failed`, name)

	return out
}

// GetInt8 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetInt32]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt8(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetInt8(cmd *cobra.Command, name string) (out int8, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return int8(viper.GetInt32(reboundKey)), nil
	}

	return cmd.Flags().GetInt8(name)
}

// MustGetBytesHexProvided is exactly like [MustGetBytesHex] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetBytesHexProvided(cmd *cobra.Command, name string) ([]byte, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "BytesHex" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetBytesHex(name)
	cli.NoError(err, `Read flag %q via "GetBytesHex" failed`, name)

	return out, flag.Changed
}

// MustGetBytesHex returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetBytesHex(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetBytesHex(cmd *cobra.Command, name string) []byte {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "BytesHex" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetBytesHex(name)
	cli.NoError(err, `Read flag %q via "GetBytesHex" failed`, name)

	return out
}

// GetBytesHex returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetBytesHex(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetBytesHex(cmd *cobra.Command, name string) (out []byte, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "BytesHex" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetBytesHex(name)
}

// MustGetBytesBase64Provided is exactly like [MustGetBytesBase64] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetBytesBase64Provided(cmd *cobra.Command, name string) ([]byte, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "BytesBase64" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetBytesBase64(name)
	cli.NoError(err, `Read flag %q via "GetBytesBase64" failed`, name)

	return out, flag.Changed
}

// MustGetBytesBase64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetBytesBase64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetBytesBase64(cmd *cobra.Command, name string) []byte {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "BytesBase64" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetBytesBase64(name)
	cli.NoError(err, `Read flag %q via "GetBytesBase64" failed`, name)

	return out
}

// GetBytesBase64 returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetBytesBase64(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetBytesBase64(cmd *cobra.Command, name string) (out []byte, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "BytesBase64" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetBytesBase64(name)
}

// MustGetIntSliceProvided is exactly like [MustGetIntSlice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetIntSliceProvided(cmd *cobra.Command, name string) ([]int, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetIntSlice(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetIntSlice(name)
	cli.NoError(err, `Read flag %q via "GetIntSlice" failed`, name)

	return out, flag.Changed
}

// MustGetIntSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetIntSlice]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIntSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetIntSlice(cmd *cobra.Command, name string) []int {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetIntSlice(reboundKey)
	}

	out, err := cmd.Flags().GetIntSlice(name)
	cli.NoError(err, `Read flag %q via "GetIntSlice" failed`, name)

	return out
}

// GetIntSlice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetIntSlice]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetIntSlice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetIntSlice(cmd *cobra.Command, name string) (out []int, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetIntSlice(reboundKey), nil
	}

	return cmd.Flags().GetIntSlice(name)
}

// MustGetStringProvided is exactly like [MustGetString] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetStringProvided(cmd *cobra.Command, name string) (string, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetString(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetString(name)
	cli.NoError(err, `Read flag %q via "GetString" failed`, name)

	return out, flag.Changed
}

// MustGetString returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetString]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetString(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetString(cmd *cobra.Command, name string) string {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetString(reboundKey)
	}

	out, err := cmd.Flags().GetString(name)
	cli.NoError(err, `Read flag %q via "GetString" failed`, name)

	return out
}

// GetString returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetString]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetString(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetString(cmd *cobra.Command, name string) (out string, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetString(reboundKey), nil
	}

	return cmd.Flags().GetString(name)
}

// MustGetStringArrayProvided is exactly like [MustGetStringArray] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetStringArrayProvided(cmd *cobra.Command, name string) ([]string, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringSlice(reboundKey), viper.IsSet(reboundKey)
	}

	out, err := cmd.Flags().GetStringArray(name)
	cli.NoError(err, `Read flag %q via "GetStringArray" failed`, name)

	return out, flag.Changed
}

// MustGetStringArray returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetStringSlice]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringArray(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetStringArray(cmd *cobra.Command, name string) []string {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringSlice(reboundKey)
	}

	out, err := cmd.Flags().GetStringArray(name)
	cli.NoError(err, `Read flag %q via "GetStringArray" failed`, name)

	return out
}

// GetStringArray returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.GetStringSlice]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetStringArray(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetStringArray(cmd *cobra.Command, name string) (out []string, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return viper.GetStringSlice(reboundKey), nil
	}

	return cmd.Flags().GetStringArray(name)
}

// MustGetInt64SliceProvided is exactly like [MustGetInt64Slice] but also
// return if the key was changed somewhere in the configuration stack.
func MustGetInt64SliceProvided(cmd *cobra.Command, name string) ([]int64, bool) {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Int64Slice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetInt64Slice(name)
	cli.NoError(err, `Read flag %q via "GetInt64Slice" failed`, name)

	return out, flag.Changed
}

// MustGetInt64Slice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// prints a message and exit with process with code 1.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method prints a message and exit with process with code 1.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt64Slice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func MustGetInt64Slice(cmd *cobra.Command, name string) []int64 {
	flag := cmd.Flags().Lookup(name)
	cli.Ensure(flag != nil, "Flag %q does not exist", name)

	if reboundKey, found := getReboundKey(flag); found {
		cli.Quit(`Viper does not support get value for type "Int64Slice" requested via flag %q (key %q)`, name, reboundKey)
	}

	out, err := cmd.Flags().GetInt64Slice(name)
	cli.NoError(err, `Read flag %q via "GetInt64Slice" failed`, name)

	return out
}

// GetInt64Slice returns the configuration value for your
// CLI. This method version lookup for the flag's name. If the flag is not found,
// exists with specific error.
//
// If the flag is found and [ConfigureViper] was used and rebound a key for it, delegate to
// [viper.Get]. Note that not all type are Viper supported, in which this
// method returns an error.
//
// Otherwise if Viper was not configured, delegates to `cmd.Flags().GetInt64Slice(name)`
//
// See [ConfigureViper] for key rebinding rules.
func GetInt64Slice(cmd *cobra.Command, name string) (out []int64, err error) {
	flag := cmd.Flags().Lookup(name)
	if flag == nil {
		return out, &ErrFlagNotExist{Name: name}
	}

	if reboundKey, found := getReboundKey(flag); found {
		return out, fmt.Errorf(`%w: unsupported type "Int64Slice" requested via flag %q (key %q)`, ErrViperTypeNotSupported, name, reboundKey)
	}

	return cmd.Flags().GetInt64Slice(name)
}

func getReboundKey(flag *pflag.Flag) (string, bool) {
	return getAnnotation(flag, cli.ReboundFlagAnnotation)
}

func getAnnotation(flag *pflag.Flag, key string) (string, bool) {
	if flag.Annotations == nil {
		return "", false
	}

	values := flag.Annotations[key]
	if len(values) == 0 {
		return "", false
	}

	return values[len(values)-1], true
}